---
title: "ENVS-193DS_spring-2025_final"
author: "Vikesh Dheeriya"
date: "2025-06-10"
output: html_document
---

https://github.com/vikeshdh/ENVS-193DS_spring-2025_final/tree/main

```{r Setup, include=FALSE}
library(tidyverse)
library(dplyr)     # data wrangling verbs
library(lubridate) # easy date handling
library(tibble)    # just for nice printing
library(janitor)
library(DHARMa)
library(MuMIn)
library(ggeffects) 
```

```{r Problem 1, include=FALSE}

```

a) In part 1, my coworker used a Spearman rank correlation, evidenced by Spearmens $\rho$ being greater than 0. This signifies that if nitrogen runoff and distance to headwaters were completely unrelated, we would only see the rho 3% of the time. In Part 2, they did a one-way ANOVA, comparing the mean nitrogen loads across five sources. The $/rho$ =0.02 tells me that the difference in means is significant. 

b) The coworker could have listed the effect size. This would tell the reader how much of the variation is explained by the individual source, like if fertilizer had a greater effect size than grasslands, for example. One additional test they could have done is a linear mixed effects model where the source (urban deposition, fertilizer, etc) is the fixed effect and the site and year are the random intercepts. This tells us whether sources are explained by differences in site or differences in year, which isn't accounted for in the ANOVA. 

c) As distance from headwaters (km) increased, there is evidence to suggest that total nitrogen load (kg year^-1) also increased ($/rho$ = correlation coefficient, n = sample size, p = 0.03, $\alpha$ = signficance level). The average nitrogen load differed between the five source categories (urban land, atmospheric deposition, fertilizer, wastewater treatment, and grasslands) with one source of nitrogen contributing more than the others (one-way ANOVA, df  = degrees of freedom, F = f-ratio, MSB = mean square, p = 0.02, $\alpha$ = 0.05)

```{r Problem 2, include=FALSE}
sst <- read.csv("data/SST_update2023.csv") # read in original SST file

sst_clean <- sst %>%                       # start with the raw data 
  
  # Add explicit year & month columns
  mutate(
    year  = year(date),                    # extract year from a date column
    month = month(date, label = TRUE,      # extract month
                  abbr  = TRUE)
  ) %>% 
  # Average within each year-month cell
  group_by(year, month) %>% 
  summarise(mean_monthly_sst = mean(temp, na.rm = TRUE),
            .groups = "drop") %>% 
  # 3. Polish data types
  mutate(
    year  = factor(year),                  # keep years as factors for plotting
    month = factor(month,
                   levels = month.abb,     # ensure Jan–Dec order
                   ordered = TRUE)
  )

 # Peek at a random five-row subset
sst_clean %>% 
  slice_sample(n = 5)

 # Show the data structure
str(sst_clean)

library(ggplot2)
library(viridis)   # for a colour-blind-friendly palette

sst_clean %>% 
  filter(year %in% 2018:2023) %>% 
  mutate(year = factor(year, levels = 2018:2023)) %>% 
  ggplot(aes(month, mean_monthly_sst,
             group = year, colour = year)) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  scale_colour_brewer(palette = "Blues", direction = 1, name = "Year") +
  labs(x = "Month",
       y = "Mean monthly sea surface temperature (°C)") +
  theme_classic(base_size = 13) +
  theme(
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
    legend.position   = c(0.08, 0.88),          # inside plot, upper-left
    legend.background = element_rect(fill = "white", colour = NA),
    legend.key        = element_rect(fill = NA)
  )
```

```{r Problem 3}
nest_boxes <- read.csv("data/occdist.csv") |>
  clean_names() |>                                   
  rename(distance_to_forest_edge = edge_distance) |> # nicer variable name
  mutate(
    season = factor(season),                         # treat season as factor
    cs     = as.numeric(cs)                          # 0 / 1 common-starling use
  )


# d) lookup table for the four candidate models
model_table <- tribble(
  ~model_number, ~season, ~distance_to_forest_edge, ~model_description,
  1,             "",      "",                       "Null model: no predictors",
  2,             "X",     "X",                      "Saturated model: all predictors",
  3,             "X",     "",                       "Season-only model",
  4,             "",      "X",                      "Distance-to-forest-edge-only model"
)

library(DHARMa)

#e)  1.  Simulate residuals
model_1_res <- simulateResiduals(model1, n = 1000)
model_2_res <- simulateResiduals(model2, n = 1000)
model_3_res <- simulateResiduals(model3, n = 1000)
model_4_res <- simulateResiduals(model4, n = 1000)

# Save current graphics settings, then set up a 4×4 layout 
old_par <- par(no.readonly = TRUE)           # store user’s defaults
par(mfrow = c(4, 4),                         # 4 rows × 4 columns
    mar   = c(3.2, 3.2, 1.5, 0.8),           # smaller margins
    cex   = 0.55, cex.axis = 0.55,           # shrink all text/symbols
    cex.lab = 0.55, cex.main = 0.55)

# f) Plot diagnostics 

# —— Model 1 ————————————————————————————————————————————————
plot(model_1_res,
     main = "Model 1",                      
     testUniform = FALSE, testDispersion = FALSE,
     testOutliers = FALSE, quantreg = FALSE)

# —— Model 2 ————————————————————————————————————————————————
plot(model_2_res,
     main = "Model 2",
     testUniform = FALSE, testDispersion = FALSE,
     testOutliers = FALSE, quantreg = FALSE)

# —— Model 3 ————————————————————————————————————————————————
plot(model_3_res,
     main = "Model 3",
     testUniform = FALSE, testDispersion = FALSE,
     testOutliers = FALSE, quantreg = FALSE)

# —— Model 4 ————————————————————————————————————————————————
plot(model_4_res,
     main = "Model 4",
     testUniform = FALSE, testDispersion = FALSE,
     testOutliers = FALSE, quantreg = FALSE)

#  Restore original graphics settings 
par(old_par)

#g) Selecting the best model

AICc(model1, model2, model3, model4) |>
  arrange(AICc)

#The best model, as determined by Akaike's Information Criterion is the model that predicts parrot occupance from both season and distance to forest edge. The high performance of this model indicates that combining season and proximity to forest edge is the best indicator of nest occupancy compared to combinations of other predictors.

#h) Visualizing model predictions

pred <- ggpredict(
  model2,
  terms = c("distance")
)

```

a) The presence of a 1 means the target species occupied the nest box while the presence of a 0 indicates there is no species/ a different species that is occupying the nest box. The 'e' column 1 and 0's indicate whether or not it is occupied, regardless of species type. 

b) The main difference between Swift Parrots and Common Starlings and Tree martins are Swift Parrots are critically endangered due to deforestation and the introduction of a new predator while the Starlings and Martins are abundant, native species that exploit nest boxes intended for Swift Parrot species preservation. 

c) The two summer breeding seasons of 2016 and 2019 represent the years where parrots were present at the site. Parrots were not present in between these years. The 2019 nesting boxes allowed the researchers to test a more effective management option, permanent boxes, compared to the 2016 breeding site. 